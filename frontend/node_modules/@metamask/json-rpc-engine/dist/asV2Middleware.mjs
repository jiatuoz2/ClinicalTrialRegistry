import { serializeError } from "@metamask/rpc-errors";
import { hasProperty } from "@metamask/utils";
import { mergeMiddleware } from "./mergeMiddleware.mjs";
import { deepClone, fromLegacyRequest, propagateToContext, propagateToRequest, deserializeError } from "./v2/compatibility-utils.mjs";
/**
 * The asV2Middleware implementation.
 *
 * @param engineOrMiddleware - A legacy engine or legacy middleware.
 * @param rest - Any additional legacy middleware when the first argument is a middleware.
 * @returns The {@link JsonRpcEngineV2} middleware.
 */
export function asV2Middleware(engineOrMiddleware, ...rest) {
    const legacyMiddleware = typeof engineOrMiddleware === 'function'
        ? // mergeMiddleware uses .asMiddleware() internally, which is necessary for our purposes.
            // See comment on this below.
            mergeMiddleware([engineOrMiddleware, ...rest])
        : engineOrMiddleware.asMiddleware();
    return async ({ request, context, next }) => {
        const req = deepClone(request);
        propagateToRequest(req, context);
        const response = await new Promise((resolve) => {
            // The result or error property will be set by the legacy engine
            // middleware.
            const res = {
                jsonrpc: '2.0',
                id: req.id,
            };
            const end = (error) => {
                if (error !== undefined) {
                    res.error = serializeError(error);
                }
                resolve(res);
            };
            // We know from the implementation of JsonRpcEngine.asMiddleware() that
            // legacyNext will always be passed a callback, so cb can never be
            // undefined.
            const legacyNext = ((cb) => cb(end));
            legacyMiddleware(req, res, legacyNext, end);
        });
        propagateToContext(req, context);
        // Mimic the behavior of JsonRpcEngine.#handle(), which only treats truthy errors as errors.
        // Legacy middleware may violate the invariant that response objects have either a result or an
        // error property. In practice, we may see response objects with results and `{ error: undefined }`.
        if (hasProperty(response, 'error') && response.error) {
            throw deserializeError(response.error);
        }
        else if (hasProperty(response, 'result')) {
            return response.result;
        }
        return next(fromLegacyRequest(req));
    };
}
//# sourceMappingURL=asV2Middleware.mjs.map