{"version":3,"file":"MiddlewareContext.mjs","sourceRoot":"","sources":["../../src/v2/MiddlewareContext.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,UAAU,EAA4B,oBAAgB;AAE/D,MAAM,uBAAuB,GAAG,MAAM,CAAC,GAAG,CAAC,mCAAmC,CAAC,CAAC;AAEhF;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAM,OAAO,iBAEX,SAAQ,GAAgD;IAGxD;;;;;;OAMG;IACH,MAAM,CAAC,UAAU,CAAC,KAAc;QAC9B,OAAO,UAAU,CAAC,KAAK,EAAE,uBAAuB,CAAC,CAAC;IACpD,CAAC;IAED,YACE,OAEa;QAEb,KAAK,CACH,OAAO,IAAI,UAAU,CAAC,OAAO,CAAC;YAC5B,CAAC,CAAC,OAAO;YACT,CAAC,CAAC,oBAAoB,CAAC,OAAO,IAAI,EAAE,CAAC,CACxC,CAAC;QAtBa,QAAyB,GAAG,IAAI,CAAC;QAuBhD,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IACtB,CAAC;IAED,GAAG,CAA4B,GAAM;QACnC,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAA6B,CAAC;IACpD,CAAC;IAED;;;;;OAKG;IACH,SAAS,CAA4B,GAAM;QACzC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;YACpB,MAAM,IAAI,KAAK,CAAC,gBAAgB,MAAM,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;QAC5D,CAAC;QACD,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAiB,CAAC;IACxC,CAAC;IAED;;;;;;;;OAQG;IACH,GAAG,CAA4B,GAAM,EAAE,KAAmB;QACxD,IAAI,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;YACnB,MAAM,IAAI,KAAK,CAAC,0BAA0B,MAAM,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAC;QAC3E,CAAC;QACD,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;QACtB,OAAO,IAAI,CAAC;IACd,CAAC;CACF;KA3DmB,uBAAuB;AA6D3C;;;;;GAKG;AACH,SAAS,UAAU,CACjB,KAAuD;IAEvD,OAAO,MAAM,CAAC,QAAQ,IAAI,KAAK,CAAC;AAClC,CAAC;AAED;;;;;;GAMG;AACH,SAAS,oBAAoB,CAC3B,SAAoB;IAEpB,OAAO,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,GAAoB,EAAE,EAAE,CAAC;QAC9D,GAAG;QACH,SAAS,CAAC,GAAG,CAAC;KACf,CAAC,CAAC;AACL,CAAC","sourcesContent":["import { isInstance, type UnionToIntersection } from './utils';\n\nconst MiddlewareContextSymbol = Symbol.for('json-rpc-engine#MiddlewareContext');\n\n/**\n * An context object for middleware that attempts to protect against accidental\n * modifications. Its interface is frozen.\n *\n * Map keys may not be directly overridden with {@link set}. Instead, use\n * {@link delete} to remove a key and then {@link set} to add a new value.\n *\n * The override protections are circumvented when using e.g. `Reflect.set`, so\n * don't do that.\n *\n * @template KeyValues - The type of the keys and values in the context.\n * @example\n * // By default, the context permits any PropertyKey as a key.\n * const context = new MiddlewareContext();\n * context.set('foo', 'bar');\n * context.get('foo'); // 'bar'\n * context.get('fizz'); // undefined\n * @example\n * // By specifying an object type, the context permits only the keys of the object.\n * type Context = MiddlewareContext<{ foo: string }>;\n * const context = new Context([['foo', 'bar']]);\n * context.get('foo'); // 'bar'\n * context.get('fizz'); // Type error\n */\nexport class MiddlewareContext<\n  KeyValues extends Record<PropertyKey, unknown> = Record<PropertyKey, unknown>,\n> extends Map<keyof KeyValues, KeyValues[keyof KeyValues]> {\n  private readonly [MiddlewareContextSymbol] = true;\n\n  /**\n   * Check if a value is a {@link MiddlewareContext} instance.\n   * Works across different package versions in the same realm.\n   *\n   * @param value - The value to check.\n   * @returns Whether the value is a {@link MiddlewareContext} instance.\n   */\n  static isInstance(value: unknown): value is MiddlewareContext {\n    return isInstance(value, MiddlewareContextSymbol);\n  }\n\n  constructor(\n    entries?:\n      | Iterable<readonly [keyof KeyValues, KeyValues[keyof KeyValues]]>\n      | KeyValues,\n  ) {\n    super(\n      entries && isIterable(entries)\n        ? entries\n        : entriesFromKeyValues(entries ?? {}),\n    );\n    Object.freeze(this);\n  }\n\n  get<K extends keyof KeyValues>(key: K): KeyValues[K] | undefined {\n    return super.get(key) as KeyValues[K] | undefined;\n  }\n\n  /**\n   * Get a value from the context. Throws if the key is not found.\n   *\n   * @param key - The key to get the value for.\n   * @returns The value.\n   */\n  assertGet<K extends keyof KeyValues>(key: K): KeyValues[K] {\n    if (!super.has(key)) {\n      throw new Error(`Context key \"${String(key)}\" not found`);\n    }\n    return super.get(key) as KeyValues[K];\n  }\n\n  /**\n   * Set a value in the context. Throws if the key already exists.\n   * {@link delete} an existing key before setting it to a new value.\n   *\n   * @throws If the key already exists.\n   * @param key - The key to set the value for.\n   * @param value - The value to set.\n   * @returns The context.\n   */\n  set<K extends keyof KeyValues>(key: K, value: KeyValues[K]): this {\n    if (super.has(key)) {\n      throw new Error(`MiddlewareContext key \"${String(key)}\" already exists`);\n    }\n    super.set(key, value);\n    return this;\n  }\n}\n\n/**\n * {@link Iterable} type guard.\n *\n * @param value - The value to check.\n * @returns Whether the value is an {@link Iterable}.\n */\nfunction isIterable(\n  value: Iterable<unknown> | Record<PropertyKey, unknown>,\n): value is Iterable<unknown> {\n  return Symbol.iterator in value;\n}\n\n/**\n * Like Object.entries(), but includes symbol-keyed properties.\n *\n * @template KeyValues - The type of the keys and values in the object.\n * @param keyValues - The object to convert.\n * @returns The array of entries, including symbol-keyed properties.\n */\nfunction entriesFromKeyValues<KeyValues extends Record<PropertyKey, unknown>>(\n  keyValues: KeyValues,\n): [keyof KeyValues, KeyValues[keyof KeyValues]][] {\n  return Reflect.ownKeys(keyValues).map((key: keyof KeyValues) => [\n    key,\n    keyValues[key],\n  ]);\n}\n\n/**\n * Infer the KeyValues type from a {@link MiddlewareContext}.\n */\nexport type InferKeyValues<T> =\n  T extends MiddlewareContext<infer U> ? U : never;\n\n/**\n * Simplifies an object type by \"merging\" its properties.\n *\n * - Expands intersections into a single object type.\n * - Forces mapped/conditional results to resolve into a readable shape.\n * - No runtime effect; purely a type-level normalization.\n *\n * @example\n * type A = { a: string } & { b: number };\n * type B = Simplify<A>; // { a: string; b: number }\n */\ntype Simplify<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;\n\n/**\n * Rejects record types that contain any `never`-valued property.\n *\n * If any property of `T` resolves to `never`, the result is `never`; otherwise it returns `T` unchanged.\n * Useful as a guard to ensure computed/merged record types didn't collapse any fields to `never`.\n *\n * @example\n * type A = ExcludeNever<{ a: string; b: never }>; // never\n * type B = ExcludeNever<{ a: string; b: number }>; // { a: string; b: number }\n */\ntype ExcludeNever<T extends Record<PropertyKey, unknown>> = {\n  [K in keyof T]-?: [T[K]] extends [never] ? K : never;\n}[keyof T] extends never\n  ? T\n  : never;\n\n/**\n * Merge a union of {@link MiddlewareContext}s into a single {@link MiddlewareContext}\n * supertype.\n *\n * @param Contexts - The union of {@link MiddlewareContext}s to merge.\n * @returns The merged {@link MiddlewareContext} supertype.\n * @example\n * type A = MiddlewareContext<{ a: string }> | MiddlewareContext<{ b: number }>;\n * type B = MergeContexts<A>; // MiddlewareContext<{ a: string, b: number }>\n */\nexport type MergeContexts<Contexts extends ContextConstraint> =\n  ExcludeNever<\n    Simplify<UnionToIntersection<InferKeyValues<Contexts>>>\n  > extends never\n    ? never\n    : MiddlewareContext<\n        ExcludeNever<Simplify<UnionToIntersection<InferKeyValues<Contexts>>>>\n      >;\n\n/**\n * A constraint for {@link MiddlewareContext} generic parameters.\n */\n// Non-polluting `any` constraint.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ContextConstraint = MiddlewareContext<any>;\n\n/**\n * The empty context type, i.e. `MiddlewareContext<{}>`.\n */\n// The empty object type is literally an empty object in this context.\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport type EmptyContext = MiddlewareContext<{}>;\n"]}