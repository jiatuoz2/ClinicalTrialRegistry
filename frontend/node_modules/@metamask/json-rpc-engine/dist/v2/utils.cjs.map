{"version":3,"file":"utils.cjs","sourceRoot":"","sources":["../../src/v2/utils.ts"],"names":[],"mappings":";;;;AAAA,2CAMyB;AAalB,MAAM,SAAS,GAAG,CACvB,GAAwD,EACzB,EAAE,CAAC,IAAA,mBAAW,EAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AAF9C,QAAA,SAAS,aAEqC;AAEpD,MAAM,cAAc,GAAG,CAC5B,GAAwB,EACY,EAAE,CAAC,CAAC,IAAA,iBAAS,EAAC,GAAG,CAAC,CAAC;AAF5C,QAAA,cAAc,kBAE8B;AAgBzD;;;;;GAKG;AACH,SAAgB,SAAS,CAAC,KAAc;IACtC,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AACxC,CAAC;AAFD,8BAEC;AAED;;;;;;GAMG;AACI,MAAM,UAAU,GAAG,CACxB,KAAc,EACd,MAAc,EACoB,EAAE,CACpC,IAAA,gBAAQ,EAAC,KAAK,CAAC,IAAI,MAAM,IAAI,KAAK,IAAI,KAAK,CAAC,MAAM,CAAC,KAAK,IAAI,CAAC;AAJlD,QAAA,UAAU,cAIwC;AAE/D,MAAM,wBAAwB,GAAG,MAAM,CAAC,GAAG,CACzC,oCAAoC,CACrC,CAAC;AAEF,MAAa,kBAAmB,SAAQ,KAAK;IAG3C,YAAY,OAAe;QACzB,KAAK,CAAC,OAAO,CAAC,CAAC;QAHA,QAA0B,GAAG,IAAI,CAAC;QAIjD,IAAI,CAAC,IAAI,GAAG,oBAAoB,CAAC;IACnC,CAAC;IAED;;;;;;OAMG;IACH,MAAM,CAAC,UAAU,CAAC,KAAc;QAC9B,OAAO,IAAA,kBAAU,EAAC,KAAK,EAAE,wBAAwB,CAAC,CAAC;IACrD,CAAC;CACF;AAlBD,gDAkBC;KAjBmB,wBAAwB","sourcesContent":["import {\n  hasProperty,\n  isObject,\n  type JsonRpcNotification,\n  type JsonRpcParams,\n  type JsonRpcRequest,\n} from '@metamask/utils';\n\nexport type {\n  Json,\n  JsonRpcParams,\n  JsonRpcRequest,\n  JsonRpcNotification,\n} from '@metamask/utils';\n\nexport type JsonRpcCall<Params extends JsonRpcParams = JsonRpcParams> =\n  | JsonRpcNotification<Params>\n  | JsonRpcRequest<Params>;\n\nexport const isRequest = <Params extends JsonRpcParams>(\n  msg: JsonRpcCall<Params> | Readonly<JsonRpcCall<Params>>,\n): msg is JsonRpcRequest<Params> => hasProperty(msg, 'id');\n\nexport const isNotification = <Params extends JsonRpcParams>(\n  msg: JsonRpcCall<Params>,\n): msg is JsonRpcNotification<Params> => !isRequest(msg);\n\n/**\n * An unholy incantation that converts a union of object types into an\n * intersection of object types.\n *\n * @example\n * type A = { a: string } | { b: number };\n * type B = UnionToIntersection<A>; // { a: string } & { b: number }\n */\nexport type UnionToIntersection<U> = (\n  U extends never ? never : (k: U) => void\n) extends (k: infer I) => void\n  ? I\n  : never;\n\n/**\n * JSON-stringifies a value.\n *\n * @param value - The value to stringify.\n * @returns The stringified value.\n */\nexport function stringify(value: unknown): string {\n  return JSON.stringify(value, null, 2);\n}\n\n/**\n * The implementation of static `isInstance` methods for classes that have them.\n *\n * @param value - The value to check.\n * @param symbol - The symbol property to check for.\n * @returns Whether the value has `{ [symbol]: true }` in its prototype chain.\n */\nexport const isInstance = (\n  value: unknown,\n  symbol: symbol,\n): value is { [key: symbol]: true } =>\n  isObject(value) && symbol in value && value[symbol] === true;\n\nconst JsonRpcEngineErrorSymbol = Symbol.for(\n  'json-rpc-engine#JsonRpcEngineError',\n);\n\nexport class JsonRpcEngineError extends Error {\n  private readonly [JsonRpcEngineErrorSymbol] = true;\n\n  constructor(message: string) {\n    super(message);\n    this.name = 'JsonRpcEngineError';\n  }\n\n  /**\n   * Check if a value is a {@link JsonRpcEngineError} instance.\n   * Works across different package versions in the same realm.\n   *\n   * @param value - The value to check.\n   * @returns Whether the value is a {@link JsonRpcEngineError} instance.\n   */\n  static isInstance(value: unknown): value is JsonRpcEngineError {\n    return isInstance(value, JsonRpcEngineErrorSymbol);\n  }\n}\n"]}