{"version":3,"file":"JsonRpcServer.mjs","sourceRoot":"","sources":["../../src/v2/JsonRpcServer.ts"],"names":[],"mappings":"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","sourcesContent":["import { rpcErrors, serializeError } from '@metamask/rpc-errors';\nimport type {\n  JsonRpcNotification,\n  JsonRpcParams,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  NonEmptyArray,\n} from '@metamask/utils';\nimport { hasProperty, isObject } from '@metamask/utils';\n\nimport type {\n  HandleOptions,\n  JsonRpcMiddleware,\n  MergedContextOf,\n  MiddlewareConstraint,\n  RequestOf,\n} from './JsonRpcEngineV2';\nimport { JsonRpcEngineV2 } from './JsonRpcEngineV2';\nimport type { JsonRpcCall } from './utils';\nimport { getUniqueId } from '../getUniqueId';\n\ntype OnError = (error: unknown) => void;\n\ntype Options<Middleware extends MiddlewareConstraint> = {\n  onError?: OnError;\n} & (\n  | {\n      engine: ReturnType<typeof JsonRpcEngineV2.create<Middleware>>;\n    }\n  | {\n      middleware: NonEmptyArray<Middleware>;\n    }\n);\n\nconst jsonrpc = '2.0' as const;\n\n/**\n * A JSON-RPC server that handles requests and notifications.\n *\n * Essentially wraps a {@link JsonRpcEngineV2} in order to create a conformant\n * yet permissive JSON-RPC 2.0 server.\n *\n * Note that the server will accept both requests and notifications via {@link handle},\n * even if the underlying engine is only able to handle one or the other.\n *\n * @example\n * ```ts\n * const server = new JsonRpcServer({\n *   engine,\n *   onError,\n * });\n *\n * const response = await server.handle(request);\n * if ('result' in response) {\n *   // Handle result\n * } else {\n *   // Handle error\n * }\n * ```\n */\nexport class JsonRpcServer<\n  Middleware extends MiddlewareConstraint = JsonRpcMiddleware,\n> {\n  readonly #engine: JsonRpcEngineV2<\n    RequestOf<Middleware>,\n    MergedContextOf<Middleware>\n  >;\n\n  readonly #onError?: OnError | undefined;\n\n  /**\n   * Construct a new JSON-RPC server.\n   *\n   * @param options - The options for the server.\n   * @param options.onError - The callback to handle errors thrown by the\n   * engine. Errors always result in a failed response object, containing a\n   * JSON-RPC 2.0 serialized version of the original error. If you need to\n   * access the original error, use the `onError` callback.\n   * @param options.engine - The engine to use. Mutually exclusive with\n   * `middleware`.\n   * @param options.middleware - The middleware to use. Mutually exclusive with\n   * `engine`.\n   */\n  constructor(options: Options<Middleware>) {\n    this.#onError = options.onError;\n\n    if (hasProperty(options, 'engine')) {\n      // @ts-expect-error - hasProperty fails to narrow the type.\n      this.#engine = options.engine;\n    } else {\n      // @ts-expect-error - TypeScript complains that engine is of the wrong type, but clearly it's not.\n      this.#engine = JsonRpcEngineV2.create({ middleware: options.middleware });\n    }\n  }\n\n  /**\n   * Handle a JSON-RPC request.\n   *\n   * This method never throws. For requests, a response is always returned.\n   * All errors are passed to the engine's `onError` callback.\n   *\n   * **WARNING**: This method is unaware of the request type of the underlying\n   * engine. The request will fail if the engine can only handle notifications.\n   *\n   * @param request - The request to handle.\n   * @param options - The options for the handle operation.\n   * @param options.context - The context to pass to the middleware.\n   * @returns The JSON-RPC response.\n   */\n  async handle(\n    request: JsonRpcRequest,\n    options?: HandleOptions<MergedContextOf<Middleware>>,\n  ): Promise<JsonRpcResponse>;\n\n  /**\n   * Handle a JSON-RPC notification.\n   *\n   * This method never throws. For notifications, `undefined` is always returned.\n   * All errors are passed to the engine's `onError` callback.\n   *\n   * **WARNING**: This method is unaware of the request type of the underlying\n   * engine. The request will fail if the engine cannot handle notifications.\n   *\n   * @param notification - The notification to handle.\n   * @param options - The options for the handle operation.\n   * @param options.context - The context to pass to the middleware.\n   */\n  async handle(\n    notification: JsonRpcNotification,\n    options?: HandleOptions<MergedContextOf<Middleware>>,\n  ): Promise<void>;\n\n  /**\n   * Handle an alleged JSON-RPC request or notification. Permits any plain\n   * object with `{ method: string }`, so long as any present JSON-RPC 2.0\n   * properties are valid. If the object has an `id` property, it will be\n   * treated as a request, otherwise it will be treated as a notification.\n   *\n   * This method never throws. All errors are passed to the engine's\n   * `onError` callback. A JSON-RPC response is always returned for requests,\n   * and `undefined` is returned for notifications.\n   *\n   * **WARNING**: The request will fail if its coerced type (i.e. request or\n   * response) is not of the type expected by the underlying engine.\n   *\n   * @param rawRequest - The raw request to handle.\n   * @param options - The options for the handle operation.\n   * @param options.context - The context to pass to the middleware.\n   * @returns The JSON-RPC response, or `undefined` if the request is a\n   * notification.\n   */\n  async handle(\n    rawRequest: unknown,\n    options?: HandleOptions<MergedContextOf<Middleware>>,\n  ): Promise<JsonRpcResponse | void>;\n\n  async handle(\n    rawRequest: unknown,\n    options?: HandleOptions<MergedContextOf<Middleware>>,\n  ): Promise<JsonRpcResponse | void> {\n    // If rawRequest is not a notification, the originalId will be attached\n    // to the response. We attach our own, trusted id in #coerceRequest()\n    // while the request is being handled.\n    const [originalId, isRequest] = getOriginalId(rawRequest);\n\n    try {\n      const request = JsonRpcServer.#coerceRequest(rawRequest, isRequest);\n      // @ts-expect-error - The request may not be of the type expected by the engine,\n      // and we intentionally allow this to happen.\n      const result = await this.#engine.handle(request, options);\n\n      if (result !== undefined) {\n        return {\n          jsonrpc,\n          // @ts-expect-error - Reassign the original id, regardless of its type.\n          id: originalId,\n          result,\n        };\n      }\n    } catch (error) {\n      this.#onError?.(error);\n\n      if (isRequest) {\n        return {\n          jsonrpc,\n          // @ts-expect-error - Reassign the original id, regardless of its type.\n          id: originalId,\n          error: serializeError(error, {\n            shouldIncludeStack: false,\n            shouldPreserveMessage: true,\n          }),\n        };\n      }\n    }\n    return undefined;\n  }\n\n  static #coerceRequest(rawRequest: unknown, isRequest: boolean): JsonRpcCall {\n    if (!isMinimalRequest(rawRequest)) {\n      throw rpcErrors.invalidRequest({\n        data: {\n          request: rawRequest,\n        },\n      });\n    }\n\n    const request: JsonRpcCall = {\n      jsonrpc,\n      method: rawRequest.method,\n    };\n\n    if (hasProperty(rawRequest, 'params')) {\n      request.params = rawRequest.params as JsonRpcParams;\n    }\n\n    if (isRequest) {\n      (request as JsonRpcRequest).id = getUniqueId();\n    }\n\n    return request;\n  }\n}\n\n/**\n * The most minimally conformant request object that we will accept.\n */\ntype MinimalRequest = {\n  method: string;\n  params?: JsonRpcParams;\n} & Record<string, unknown>;\n\n/**\n * Check if an unvalidated request is a minimal request.\n *\n * @param rawRequest - The raw request to check.\n * @returns `true` if the request is a {@link MinimalRequest}, `false` otherwise.\n */\nfunction isMinimalRequest(rawRequest: unknown): rawRequest is MinimalRequest {\n  return (\n    isObject(rawRequest) &&\n    hasProperty(rawRequest, 'method') &&\n    typeof rawRequest.method === 'string' &&\n    hasValidParams(rawRequest)\n  );\n}\n\n/**\n * Check if a request has valid params, i.e. an array or object.\n * The contents of the params are not inspected.\n *\n * @param rawRequest - The request to check.\n * @returns `true` if the request has valid params, `false` otherwise.\n */\nfunction hasValidParams(\n  rawRequest: Record<string, unknown>,\n): rawRequest is { params?: JsonRpcParams } {\n  if (hasProperty(rawRequest, 'params')) {\n    return Array.isArray(rawRequest.params) || isObject(rawRequest.params);\n  }\n  return true;\n}\n\n/**\n * Get the original id from a request.\n *\n * @param rawRequest - The request to get the original id from.\n * @returns The original id and a boolean indicating if the request is a request\n * (as opposed to a notification).\n */\nfunction getOriginalId(rawRequest: unknown): [unknown, boolean] {\n  if (isObject(rawRequest) && hasProperty(rawRequest, 'id')) {\n    return [rawRequest.id, true];\n  }\n  return [undefined, false];\n}\n"]}