{"version":3,"file":"JsonRpcEngineV2.mjs","sourceRoot":"","sources":["../../src/v2/JsonRpcEngineV2.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  type Json,\n  type JsonRpcRequest,\n  type JsonRpcNotification,\n  type NonEmptyArray,\n  hasProperty,\n} from '@metamask/utils';\nimport deepFreeze from 'deep-freeze-strict';\n\nimport type {\n  ContextConstraint,\n  InferKeyValues,\n  MergeContexts,\n} from './MiddlewareContext';\nimport { MiddlewareContext } from './MiddlewareContext';\nimport {\n  isNotification,\n  isRequest,\n  JsonRpcEngineError,\n  stringify,\n} from './utils';\nimport type { JsonRpcCall } from './utils';\n\n// Helper to forbid `id` on notifications\ntype WithoutId<Request extends JsonRpcCall> = Request & { id?: never };\n\n// Helper to enable JsonRpcCall overload of handle()\ntype MixedParam<Request extends JsonRpcCall> = [\n  Extract<Request, JsonRpcRequest>,\n] extends [never]\n  ? never\n  : [Extract<Request, JsonRpcNotification>] extends [never]\n    ? never\n    :\n        | Extract<Request, JsonRpcRequest>\n        | WithoutId<Extract<Request, JsonRpcNotification>>;\n\nexport type ResultConstraint<Request extends JsonRpcCall> =\n  Request extends JsonRpcRequest ? Json : void;\n\nexport type Next<Request extends JsonRpcCall> = (\n  request?: Readonly<Request>,\n) => Promise<Readonly<ResultConstraint<Request>> | undefined>;\n\nexport type MiddlewareParams<\n  Request extends JsonRpcCall = JsonRpcCall,\n  Context extends ContextConstraint = MiddlewareContext,\n> = {\n  request: Readonly<Request>;\n  context: Context;\n  next: Next<Request>;\n};\n\nexport type JsonRpcMiddleware<\n  Request extends JsonRpcCall = JsonRpcCall,\n  Result extends ResultConstraint<Request> = ResultConstraint<Request>,\n  Context extends ContextConstraint = MiddlewareContext,\n> = (\n  params: MiddlewareParams<Request, Context>,\n) => Readonly<Result> | undefined | Promise<Readonly<Result> | undefined>;\n\ntype RequestState<Request extends JsonRpcCall> = {\n  request: Request;\n  result: Readonly<ResultConstraint<Request>> | undefined;\n};\n\n/**\n * The options for the JSON-RPC request/notification handling operation.\n */\nexport type HandleOptions<Context extends ContextConstraint> = {\n  context?: Context | InferKeyValues<Context>;\n};\n\ntype ConstructorOptions<\n  Request extends JsonRpcCall,\n  Context extends MiddlewareContext,\n> = {\n  middleware: NonEmptyArray<\n    JsonRpcMiddleware<Request, ResultConstraint<Request>, Context>\n  >;\n};\n\n/**\n * The request type of a middleware.\n */\nexport type RequestOf<Middleware> =\n  Middleware extends JsonRpcMiddleware<\n    infer Request,\n    ResultConstraint<infer Request>,\n    // Non-polluting `any` constraint.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    any\n  >\n    ? Request\n    : never;\n\ntype ContextOf<Middleware> =\n  // Non-polluting `any` constraint.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Middleware extends JsonRpcMiddleware<any, ResultConstraint<any>, infer C>\n    ? C\n    : never;\n\n/**\n * A constraint for {@link JsonRpcMiddleware} generic parameters.\n */\n// Non-polluting `any` constraint.\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport type MiddlewareConstraint = JsonRpcMiddleware<\n  any,\n  ResultConstraint<any>,\n  MiddlewareContext<any>\n>;\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/**\n * The context supertype of a middleware type.\n */\nexport type MergedContextOf<Middleware extends MiddlewareConstraint> =\n  MergeContexts<ContextOf<Middleware>>;\n\nconst INVALID_ENGINE = Symbol('Invalid engine');\n\n/**\n * An internal type for invalid engines that explains why the engine is invalid.\n *\n * @template Message - The message explaining why the engine is invalid.\n */\ntype InvalidEngine<Message extends string> = { [INVALID_ENGINE]: Message };\n\n/**\n * A JSON-RPC request and response processor.\n *\n * Give it a stack of middleware, pass it requests, and get back responses.\n *\n * #### Requests vs. notifications\n *\n * JSON-RPC requests come in two flavors:\n *\n * - [Requests](https://www.jsonrpc.org/specification#request_object), i.e. request objects _with_ an `id`\n * - [Notifications](https://www.jsonrpc.org/specification#notification), i.e. request objects _without_ an `id`\n *\n * For requests, one of the engine's middleware must \"end\" the request by returning a non-`undefined` result,\n * or {@link handle} will throw an error:\n *\n * For notifications, on the other hand, one of the engine's middleware must return `undefined` to end the request,\n * and any non-`undefined` return values will cause an error:\n *\n * @template Request - The type of request to handle.\n * @template Result - The type of result to return.\n *\n * @example\n * ```ts\n * const engine = JsonRpcEngineV2.create({\n *   middleware,\n * });\n *\n * try {\n *   const result = await engine.handle(request);\n *   // Handle result\n * } catch (error) {\n *   // Handle error\n * }\n * ```\n */\nexport class JsonRpcEngineV2<\n  Request extends JsonRpcCall = JsonRpcCall,\n  Context extends ContextConstraint = MiddlewareContext,\n> {\n  #middleware: Readonly<\n    NonEmptyArray<\n      JsonRpcMiddleware<Request, ResultConstraint<Request>, Context>\n    >\n  >;\n\n  #isDestroyed = false;\n\n  // See .create() for why this is private.\n  private constructor({ middleware }: ConstructorOptions<Request, Context>) {\n    this.#middleware = [...middleware];\n  }\n\n  // We use a static factory method in order to construct a supertype of all middleware contexts,\n  // which enables us to instantiate an engine despite different middleware expecting different\n  // context types.\n  /**\n   * Create a new JSON-RPC engine.\n   *\n   * @throws If the middleware array is empty.\n   * @param options - The options for the engine.\n   * @param options.middleware - The middleware to use.\n   * @returns The JSON-RPC engine.\n   */\n  static create<\n    Middleware extends JsonRpcMiddleware<\n      // Non-polluting `any` constraint.\n      /* eslint-disable @typescript-eslint/no-explicit-any */\n      any,\n      ResultConstraint<any>,\n      any\n      /* eslint-enable @typescript-eslint/no-explicit-any */\n    > = JsonRpcMiddleware,\n  >({ middleware }: { middleware: Middleware[] }) {\n    // We can't use NonEmptyArray for the params because it ruins type inference.\n    if (middleware.length === 0) {\n      throw new JsonRpcEngineError('Middleware array cannot be empty');\n    }\n\n    type MergedContext = MergedContextOf<Middleware>;\n    type InputRequest = RequestOf<Middleware>;\n    const mw = middleware as unknown as NonEmptyArray<\n      JsonRpcMiddleware<\n        InputRequest,\n        ResultConstraint<InputRequest>,\n        MergedContext\n      >\n    >;\n    return new JsonRpcEngineV2<InputRequest, MergedContext>({\n      middleware: mw,\n    }) as MergedContext extends never\n      ? InvalidEngine<'Some middleware have incompatible context types'>\n      : JsonRpcEngineV2<InputRequest, MergedContext>;\n  }\n\n  /**\n   * Handle a JSON-RPC request.\n   *\n   * @param request - The JSON-RPC request to handle.\n   * @param options - The options for the handle operation.\n   * @param options.context - The context to pass to the middleware.\n   * @returns The JSON-RPC response.\n   */\n  async handle(\n    request: Extract<Request, JsonRpcRequest> extends never\n      ? never\n      : Extract<Request, JsonRpcRequest>,\n    options?: HandleOptions<Context>,\n  ): Promise<\n    Extract<Request, JsonRpcRequest> extends never\n      ? never\n      : ResultConstraint<Request>\n  >;\n\n  /**\n   * Handle a JSON-RPC notification. Notifications do not return a result.\n   *\n   * @param notification - The JSON-RPC notification to handle.\n   * @param options - The options for the handle operation.\n   * @param options.context - The context to pass to the middleware.\n   */\n  async handle(\n    notification: Extract<Request, JsonRpcNotification> extends never\n      ? never\n      : WithoutId<Extract<Request, JsonRpcNotification>>,\n    options?: HandleOptions<Context>,\n  ): Promise<\n    Extract<Request, JsonRpcNotification> extends never\n      ? never\n      : ResultConstraint<Request>\n  >;\n\n  /**\n   * Handle a JSON-RPC call, i.e. request or notification. Requests return a\n   * result, notifications do not.\n   *\n   * @param call - The JSON-RPC call to handle.\n   * @param options - The options for the handle operation.\n   * @param options.context - The context to pass to the middleware.\n   * @returns The JSON-RPC response, or `undefined` if the call is a notification.\n   */\n  async handle(\n    call: MixedParam<Request>,\n    options?: HandleOptions<Context>,\n  ): Promise<ResultConstraint<Request> | void>;\n\n  async handle(\n    request: Request,\n    { context }: HandleOptions<Context> = {},\n  ): Promise<Readonly<ResultConstraint<Request>> | void> {\n    const isReq = isRequest(request);\n    const { result } = await this.#handle(request, context);\n\n    if (isReq && result === undefined) {\n      throw new JsonRpcEngineError(\n        `Nothing ended request: ${stringify(request)}`,\n      );\n    }\n    return result;\n  }\n\n  /**\n   * Handle a JSON-RPC request. Throws if a middleware performs an invalid\n   * operation. Permits returning an `undefined` result.\n   *\n   * @param originalRequest - The JSON-RPC request to handle.\n   * @param rawContext - The context to pass to the middleware.\n   * @returns The result from the middleware.\n   */\n  async #handle(\n    originalRequest: Request,\n    rawContext:\n      | Context\n      | InferKeyValues<Context> = new MiddlewareContext() as Context,\n  ): Promise<RequestState<Request>> {\n    this.#assertIsNotDestroyed();\n\n    deepFreeze(originalRequest);\n\n    const state: RequestState<Request> = {\n      request: originalRequest,\n      result: undefined,\n    };\n    const middlewareIterator = this.#makeMiddlewareIterator();\n    const firstMiddleware = middlewareIterator.next().value;\n    const context = MiddlewareContext.isInstance(rawContext)\n      ? rawContext\n      : (new MiddlewareContext(rawContext) as Context);\n\n    const makeNext = this.#makeNextFactory(middlewareIterator, state, context);\n\n    const result = await firstMiddleware({\n      request: originalRequest,\n      context,\n      next: makeNext(),\n    });\n    this.#updateResult(result, state);\n\n    return state;\n  }\n\n  /**\n   * Create a factory of `next()` functions for use with a particular request.\n   * The factory is recursive, and a new `next()` is created for each middleware\n   * invocation.\n   *\n   * @param middlewareIterator - The iterator of middleware for the current\n   * request.\n   * @param state - The current values of the request and result.\n   * @param context - The context to pass to the middleware.\n   * @returns The `next()` function factory.\n   */\n  #makeNextFactory(\n    middlewareIterator: Iterator<\n      JsonRpcMiddleware<Request, ResultConstraint<Request>, Context>\n    >,\n    state: RequestState<Request>,\n    context: Context,\n  ): () => Next<Request> {\n    const makeNext = (): Next<Request> => {\n      let wasCalled = false;\n\n      const next = async (\n        request: Request = state.request,\n      ): Promise<Readonly<ResultConstraint<Request>> | undefined> => {\n        if (wasCalled) {\n          throw new JsonRpcEngineError(\n            `Middleware attempted to call next() multiple times for request: ${stringify(request)}`,\n          );\n        }\n        wasCalled = true;\n\n        if (request !== state.request) {\n          this.#assertValidNextRequest(state.request, request);\n          state.request = deepFreeze(request);\n        }\n\n        const { value: nextMiddleware, done } = middlewareIterator.next();\n        if (done) {\n          // This will cause the last middleware to return `undefined`. See the class\n          // JSDoc or package README for more details.\n          return undefined;\n        }\n\n        const result = await nextMiddleware({\n          request,\n          context,\n          next: makeNext(),\n        });\n        this.#updateResult(result, state);\n\n        return state.result;\n      };\n      return next;\n    };\n\n    return makeNext;\n  }\n\n  #makeMiddlewareIterator(): Iterator<\n    JsonRpcMiddleware<Request, ResultConstraint<Request>, Context>\n  > {\n    return this.#middleware[Symbol.iterator]();\n  }\n\n  /**\n   * Validate the result from a middleware and, if it's a new value, update the\n   * current result.\n   *\n   * @param result - The result from the middleware.\n   * @param state - The current values of the request and result.\n   */\n  #updateResult(\n    result:\n      | Readonly<ResultConstraint<Request>>\n      | ResultConstraint<Request>\n      | void,\n    state: RequestState<Request>,\n  ): void {\n    if (isNotification(state.request) && result !== undefined) {\n      throw new JsonRpcEngineError(\n        `Result returned for notification: ${stringify(state.request)}`,\n      );\n    }\n\n    if (result !== undefined && result !== state.result) {\n      if (typeof result === 'object' && result !== null) {\n        deepFreeze(result);\n      }\n      state.result = result;\n    }\n  }\n\n  /**\n   * Assert that a request modified by a middleware is valid.\n   *\n   * @param currentRequest - The current request.\n   * @param nextRequest - The next request.\n   */\n  #assertValidNextRequest(currentRequest: Request, nextRequest: Request): void {\n    if (nextRequest.jsonrpc !== currentRequest.jsonrpc) {\n      throw new JsonRpcEngineError(\n        `Middleware attempted to modify readonly property \"jsonrpc\" for request: ${stringify(currentRequest)}`,\n      );\n    }\n    if (\n      hasProperty(nextRequest, 'id') !== hasProperty(currentRequest, 'id') ||\n      // @ts-expect-error - \"id\" does not exist on notifications, but we can still\n      // check the value of the property at runtime.\n      nextRequest.id !== currentRequest.id\n    ) {\n      throw new JsonRpcEngineError(\n        `Middleware attempted to modify readonly property \"id\" for request: ${stringify(currentRequest)}`,\n      );\n    }\n  }\n\n  /**\n   * Convert the engine into a JSON-RPC middleware.\n   *\n   * @returns The JSON-RPC middleware.\n   */\n  asMiddleware(): JsonRpcMiddleware<\n    Request,\n    ResultConstraint<Request>,\n    Context\n  > {\n    this.#assertIsNotDestroyed();\n\n    return async ({ request, context, next }) => {\n      const { result, request: finalRequest } = await this.#handle(\n        request,\n        context,\n      );\n      return result === undefined ? await next(finalRequest) : result;\n    };\n  }\n\n  /**\n   * Destroy the engine. Calls the `destroy()` method of any middleware that has\n   * one. Attempting to use the engine after destroying it will throw an error.\n   */\n  async destroy(): Promise<void> {\n    if (this.#isDestroyed) {\n      return;\n    }\n    this.#isDestroyed = true;\n\n    const destructionPromise = Promise.all(\n      this.#middleware.map(async (middleware) => {\n        if (\n          // Intentionally using `in` to walk the prototype chain.\n          'destroy' in middleware &&\n          typeof middleware.destroy === 'function'\n        ) {\n          return middleware.destroy();\n        }\n        return undefined;\n      }),\n    );\n    this.#middleware = [] as never;\n    await destructionPromise;\n  }\n\n  #assertIsNotDestroyed(): void {\n    if (this.#isDestroyed) {\n      throw new JsonRpcEngineError('Engine is destroyed');\n    }\n  }\n}\n"]}