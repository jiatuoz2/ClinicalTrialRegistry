var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _JsonRpcEngineV2_instances, _JsonRpcEngineV2_middleware, _JsonRpcEngineV2_isDestroyed, _JsonRpcEngineV2_handle, _JsonRpcEngineV2_makeNextFactory, _JsonRpcEngineV2_makeMiddlewareIterator, _JsonRpcEngineV2_updateResult, _JsonRpcEngineV2_assertValidNextRequest, _JsonRpcEngineV2_assertIsNotDestroyed;
function $importDefault(module) {
    if (module?.__esModule) {
        return module.default;
    }
    return module;
}
import { hasProperty } from "@metamask/utils";
import $deepFreeze from "deep-freeze-strict";
const deepFreeze = $importDefault($deepFreeze);
import { MiddlewareContext } from "./MiddlewareContext.mjs";
import { isNotification, isRequest, JsonRpcEngineError, stringify } from "./utils.mjs";
const INVALID_ENGINE = Symbol('Invalid engine');
/**
 * A JSON-RPC request and response processor.
 *
 * Give it a stack of middleware, pass it requests, and get back responses.
 *
 * #### Requests vs. notifications
 *
 * JSON-RPC requests come in two flavors:
 *
 * - [Requests](https://www.jsonrpc.org/specification#request_object), i.e. request objects _with_ an `id`
 * - [Notifications](https://www.jsonrpc.org/specification#notification), i.e. request objects _without_ an `id`
 *
 * For requests, one of the engine's middleware must "end" the request by returning a non-`undefined` result,
 * or {@link handle} will throw an error:
 *
 * For notifications, on the other hand, one of the engine's middleware must return `undefined` to end the request,
 * and any non-`undefined` return values will cause an error:
 *
 * @template Request - The type of request to handle.
 * @template Result - The type of result to return.
 *
 * @example
 * ```ts
 * const engine = JsonRpcEngineV2.create({
 *   middleware,
 * });
 *
 * try {
 *   const result = await engine.handle(request);
 *   // Handle result
 * } catch (error) {
 *   // Handle error
 * }
 * ```
 */
export class JsonRpcEngineV2 {
    // See .create() for why this is private.
    constructor({ middleware }) {
        _JsonRpcEngineV2_instances.add(this);
        _JsonRpcEngineV2_middleware.set(this, void 0);
        _JsonRpcEngineV2_isDestroyed.set(this, false);
        __classPrivateFieldSet(this, _JsonRpcEngineV2_middleware, [...middleware], "f");
    }
    // We use a static factory method in order to construct a supertype of all middleware contexts,
    // which enables us to instantiate an engine despite different middleware expecting different
    // context types.
    /**
     * Create a new JSON-RPC engine.
     *
     * @throws If the middleware array is empty.
     * @param options - The options for the engine.
     * @param options.middleware - The middleware to use.
     * @returns The JSON-RPC engine.
     */
    static create({ middleware }) {
        // We can't use NonEmptyArray for the params because it ruins type inference.
        if (middleware.length === 0) {
            throw new JsonRpcEngineError('Middleware array cannot be empty');
        }
        const mw = middleware;
        return new JsonRpcEngineV2({
            middleware: mw,
        });
    }
    async handle(request, { context } = {}) {
        const isReq = isRequest(request);
        const { result } = await __classPrivateFieldGet(this, _JsonRpcEngineV2_instances, "m", _JsonRpcEngineV2_handle).call(this, request, context);
        if (isReq && result === undefined) {
            throw new JsonRpcEngineError(`Nothing ended request: ${stringify(request)}`);
        }
        return result;
    }
    /**
     * Convert the engine into a JSON-RPC middleware.
     *
     * @returns The JSON-RPC middleware.
     */
    asMiddleware() {
        __classPrivateFieldGet(this, _JsonRpcEngineV2_instances, "m", _JsonRpcEngineV2_assertIsNotDestroyed).call(this);
        return async ({ request, context, next }) => {
            const { result, request: finalRequest } = await __classPrivateFieldGet(this, _JsonRpcEngineV2_instances, "m", _JsonRpcEngineV2_handle).call(this, request, context);
            return result === undefined ? await next(finalRequest) : result;
        };
    }
    /**
     * Destroy the engine. Calls the `destroy()` method of any middleware that has
     * one. Attempting to use the engine after destroying it will throw an error.
     */
    async destroy() {
        if (__classPrivateFieldGet(this, _JsonRpcEngineV2_isDestroyed, "f")) {
            return;
        }
        __classPrivateFieldSet(this, _JsonRpcEngineV2_isDestroyed, true, "f");
        const destructionPromise = Promise.all(__classPrivateFieldGet(this, _JsonRpcEngineV2_middleware, "f").map(async (middleware) => {
            if (
            // Intentionally using `in` to walk the prototype chain.
            'destroy' in middleware &&
                typeof middleware.destroy === 'function') {
                return middleware.destroy();
            }
            return undefined;
        }));
        __classPrivateFieldSet(this, _JsonRpcEngineV2_middleware, [], "f");
        await destructionPromise;
    }
}
_JsonRpcEngineV2_middleware = new WeakMap(), _JsonRpcEngineV2_isDestroyed = new WeakMap(), _JsonRpcEngineV2_instances = new WeakSet(), _JsonRpcEngineV2_handle = 
/**
 * Handle a JSON-RPC request. Throws if a middleware performs an invalid
 * operation. Permits returning an `undefined` result.
 *
 * @param originalRequest - The JSON-RPC request to handle.
 * @param rawContext - The context to pass to the middleware.
 * @returns The result from the middleware.
 */
async function _JsonRpcEngineV2_handle(originalRequest, rawContext = new MiddlewareContext()) {
    __classPrivateFieldGet(this, _JsonRpcEngineV2_instances, "m", _JsonRpcEngineV2_assertIsNotDestroyed).call(this);
    deepFreeze(originalRequest);
    const state = {
        request: originalRequest,
        result: undefined,
    };
    const middlewareIterator = __classPrivateFieldGet(this, _JsonRpcEngineV2_instances, "m", _JsonRpcEngineV2_makeMiddlewareIterator).call(this);
    const firstMiddleware = middlewareIterator.next().value;
    const context = MiddlewareContext.isInstance(rawContext)
        ? rawContext
        : new MiddlewareContext(rawContext);
    const makeNext = __classPrivateFieldGet(this, _JsonRpcEngineV2_instances, "m", _JsonRpcEngineV2_makeNextFactory).call(this, middlewareIterator, state, context);
    const result = await firstMiddleware({
        request: originalRequest,
        context,
        next: makeNext(),
    });
    __classPrivateFieldGet(this, _JsonRpcEngineV2_instances, "m", _JsonRpcEngineV2_updateResult).call(this, result, state);
    return state;
}, _JsonRpcEngineV2_makeNextFactory = function _JsonRpcEngineV2_makeNextFactory(middlewareIterator, state, context) {
    const makeNext = () => {
        let wasCalled = false;
        const next = async (request = state.request) => {
            if (wasCalled) {
                throw new JsonRpcEngineError(`Middleware attempted to call next() multiple times for request: ${stringify(request)}`);
            }
            wasCalled = true;
            if (request !== state.request) {
                __classPrivateFieldGet(this, _JsonRpcEngineV2_instances, "m", _JsonRpcEngineV2_assertValidNextRequest).call(this, state.request, request);
                state.request = deepFreeze(request);
            }
            const { value: nextMiddleware, done } = middlewareIterator.next();
            if (done) {
                // This will cause the last middleware to return `undefined`. See the class
                // JSDoc or package README for more details.
                return undefined;
            }
            const result = await nextMiddleware({
                request,
                context,
                next: makeNext(),
            });
            __classPrivateFieldGet(this, _JsonRpcEngineV2_instances, "m", _JsonRpcEngineV2_updateResult).call(this, result, state);
            return state.result;
        };
        return next;
    };
    return makeNext;
}, _JsonRpcEngineV2_makeMiddlewareIterator = function _JsonRpcEngineV2_makeMiddlewareIterator() {
    return __classPrivateFieldGet(this, _JsonRpcEngineV2_middleware, "f")[Symbol.iterator]();
}, _JsonRpcEngineV2_updateResult = function _JsonRpcEngineV2_updateResult(result, state) {
    if (isNotification(state.request) && result !== undefined) {
        throw new JsonRpcEngineError(`Result returned for notification: ${stringify(state.request)}`);
    }
    if (result !== undefined && result !== state.result) {
        if (typeof result === 'object' && result !== null) {
            deepFreeze(result);
        }
        state.result = result;
    }
}, _JsonRpcEngineV2_assertValidNextRequest = function _JsonRpcEngineV2_assertValidNextRequest(currentRequest, nextRequest) {
    if (nextRequest.jsonrpc !== currentRequest.jsonrpc) {
        throw new JsonRpcEngineError(`Middleware attempted to modify readonly property "jsonrpc" for request: ${stringify(currentRequest)}`);
    }
    if (hasProperty(nextRequest, 'id') !== hasProperty(currentRequest, 'id') ||
        // @ts-expect-error - "id" does not exist on notifications, but we can still
        // check the value of the property at runtime.
        nextRequest.id !== currentRequest.id) {
        throw new JsonRpcEngineError(`Middleware attempted to modify readonly property "id" for request: ${stringify(currentRequest)}`);
    }
}, _JsonRpcEngineV2_assertIsNotDestroyed = function _JsonRpcEngineV2_assertIsNotDestroyed() {
    if (__classPrivateFieldGet(this, _JsonRpcEngineV2_isDestroyed, "f")) {
        throw new JsonRpcEngineError('Engine is destroyed');
    }
};
//# sourceMappingURL=JsonRpcEngineV2.mjs.map