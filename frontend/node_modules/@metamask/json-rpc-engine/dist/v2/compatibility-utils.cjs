"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeError = exports.propagateToRequest = exports.propagateToContext = exports.makeContext = exports.fromLegacyRequest = exports.requestProps = exports.deepClone = void 0;
const rpc_errors_1 = require("@metamask/rpc-errors");
const utils_1 = require("@metamask/utils");
// ATTN: We must NOT use 'klona/full' here because it freezes properties on the clone.
const klona_1 = require("klona");
const MiddlewareContext_1 = require("./MiddlewareContext.cjs");
const utils_2 = require("./utils.cjs");
// Legacy engine compatibility utils
/**
 * Create a deep clone of a value as follows:
 * - Assumes acyclical objects
 * - Does not copy property descriptors (i.e. uses mutable defaults)
 * - Ignores non-enumerable properties
 * - Ignores getters and setters
 *
 * @throws If the value is an object with a circular reference.
 * @param value - The value to clone.
 * @returns The cloned value.
 */
const deepClone = (value) => (0, klona_1.klona)(value);
exports.deepClone = deepClone;
/**
 * Standard JSON-RPC request properties.
 */
exports.requestProps = ['jsonrpc', 'method', 'params', 'id'];
/**
 * Make a JSON-RPC request from a legacy request. Clones the params to avoid
 * freezing them, which could cause errors in an involved legacy engine.
 *
 * @param req - The legacy request to make a request from.
 * @returns The JSON-RPC request.
 */
function fromLegacyRequest(req) {
    const request = {
        jsonrpc: '2.0',
        method: req.method,
    };
    request.id = req.id;
    if ((0, utils_1.hasProperty)(req, 'params') && req.params !== undefined) {
        request.params = (0, exports.deepClone)(req.params);
    }
    return request;
}
exports.fromLegacyRequest = fromLegacyRequest;
/**
 * Make a middleware context from a legacy request by copying over all non-JSON-RPC
 * properties from the request to the context object.
 *
 * @param req - The legacy request to make a context from.
 * @returns The middleware context.
 */
function makeContext(req) {
    const context = new MiddlewareContext_1.MiddlewareContext();
    propagateToContext(req, context);
    return context;
}
exports.makeContext = makeContext;
/**
 * Copies non-JSON-RPC string properties from the request to the context.
 *
 * For compatibility with our problematic practice of appending non-standard
 * fields to requests for inter-middleware communication in the legacy engine.
 *
 * **ATTN:** Only string properties that do not already exist in the context
 * are copied.
 *
 * @param req - The request to propagate the context from.
 * @param context - The context to propagate to.
 */
function propagateToContext(req, context) {
    Object.keys(req)
        .filter((key) => typeof key === 'string' &&
        !exports.requestProps.includes(key) &&
        !context.has(key))
        .forEach((key) => {
        context.set(key, req[key]);
    });
}
exports.propagateToContext = propagateToContext;
/**
 * Copies non-JSON-RPC string properties from the context to the request.
 *
 * For compatibility with our problematic practice of appending non-standard
 * fields to requests for inter-middleware communication in the legacy engine.
 *
 * **ATTN:** Only string properties are copied.
 *
 * @param req - The request to propagate the context to.
 * @param context - The context to propagate from.
 */
function propagateToRequest(req, context) {
    Array.from(context.keys())
        .filter(((key) => typeof key === 'string' && !exports.requestProps.includes(key)))
        .forEach((key) => {
        req[key] = context.get(key);
    });
}
exports.propagateToRequest = propagateToRequest;
/**
 * Unserialize an error from a thrown value. Creates a {@link JsonRpcError} if
 * the thrown value is an object with a `code` property. Otherwise, creates a
 * plain {@link Error}.
 *
 * @param thrown - The thrown value to unserialize.
 * @returns The unserialized error.
 */
function deserializeError(thrown) {
    // @ts-expect-error - New, but preferred if available.
    // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/isError
    if (typeof Error.isError === 'function' && Error.isError(thrown)) {
        return thrown;
    }
    // Unlike Error.isError, instanceof does not work for Errors from other realms.
    if (thrown instanceof Error) {
        return thrown;
    }
    if (typeof thrown === 'string') {
        return new Error(thrown);
    }
    if (!(0, utils_1.isObject)(thrown)) {
        return new Error(`Unknown error: ${(0, utils_2.stringify)(thrown)}`);
    }
    const code = typeof thrown.code === 'number' && Number.isInteger(thrown.code)
        ? thrown.code
        : undefined;
    let message = 'Unknown error';
    if (typeof thrown.message === 'string') {
        message = thrown.message;
    }
    else if (typeof code === 'number') {
        message = (0, rpc_errors_1.getMessageFromCode)(code, message);
    }
    const { stack, cause, data } = thrown;
    const error = code === undefined
        ? // Jest complains if we use the `@ts-expect-error` directive here.
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore - Our error type is outdated.
            new Error(message, { cause })
        : new rpc_errors_1.JsonRpcError(code, message, {
            ...((0, utils_1.isObject)(data) ? data : undefined),
            cause,
        });
    if (typeof stack === 'string') {
        error.stack = stack;
    }
    return error;
}
exports.deserializeError = deserializeError;
//# sourceMappingURL=compatibility-utils.cjs.map