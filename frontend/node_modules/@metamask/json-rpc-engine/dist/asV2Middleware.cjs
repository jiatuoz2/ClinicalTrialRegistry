"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asV2Middleware = void 0;
const rpc_errors_1 = require("@metamask/rpc-errors");
const utils_1 = require("@metamask/utils");
const mergeMiddleware_1 = require("./mergeMiddleware.cjs");
const compatibility_utils_1 = require("./v2/compatibility-utils.cjs");
/**
 * The asV2Middleware implementation.
 *
 * @param engineOrMiddleware - A legacy engine or legacy middleware.
 * @param rest - Any additional legacy middleware when the first argument is a middleware.
 * @returns The {@link JsonRpcEngineV2} middleware.
 */
function asV2Middleware(engineOrMiddleware, ...rest) {
    const legacyMiddleware = typeof engineOrMiddleware === 'function'
        ? // mergeMiddleware uses .asMiddleware() internally, which is necessary for our purposes.
            // See comment on this below.
            (0, mergeMiddleware_1.mergeMiddleware)([engineOrMiddleware, ...rest])
        : engineOrMiddleware.asMiddleware();
    return async ({ request, context, next }) => {
        const req = (0, compatibility_utils_1.deepClone)(request);
        (0, compatibility_utils_1.propagateToRequest)(req, context);
        const response = await new Promise((resolve) => {
            // The result or error property will be set by the legacy engine
            // middleware.
            const res = {
                jsonrpc: '2.0',
                id: req.id,
            };
            const end = (error) => {
                if (error !== undefined) {
                    res.error = (0, rpc_errors_1.serializeError)(error);
                }
                resolve(res);
            };
            // We know from the implementation of JsonRpcEngine.asMiddleware() that
            // legacyNext will always be passed a callback, so cb can never be
            // undefined.
            const legacyNext = ((cb) => cb(end));
            legacyMiddleware(req, res, legacyNext, end);
        });
        (0, compatibility_utils_1.propagateToContext)(req, context);
        // Mimic the behavior of JsonRpcEngine.#handle(), which only treats truthy errors as errors.
        // Legacy middleware may violate the invariant that response objects have either a result or an
        // error property. In practice, we may see response objects with results and `{ error: undefined }`.
        if ((0, utils_1.hasProperty)(response, 'error') && response.error) {
            throw (0, compatibility_utils_1.deserializeError)(response.error);
        }
        else if ((0, utils_1.hasProperty)(response, 'result')) {
            return response.result;
        }
        return next((0, compatibility_utils_1.fromLegacyRequest)(req));
    };
}
exports.asV2Middleware = asV2Middleware;
//# sourceMappingURL=asV2Middleware.cjs.map